/**
 * ProWritingAid API V2
 * Official ProWritingAid API Version 2
 *
 * OpenAPI spec version: v2
 * Contact: hello@prowritingaid.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.prowritingaid.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AnalysisSettings {
    'ShortestAverageSentenceLength': number;
    'LongestAverageSentenceLength': number;
    'LongestIndividualSentence': number;
    'HighestPassiveIndex': number;
    'MaxGlueIndex': number;
    'MinSentenceVariety': number;
    'HighestPronounPercentage': number;
    'LowestPronounPercentage': number;
    'HighestAcademicPronounPercentage': number;
    'HighestInitialPronounPercentage': number;
    'LowestInitialPronounPercentage': number;
    'LowestWeWeScore': number;
    'LongestAverageParagraphLength': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ShortestAverageSentenceLength",
            "baseName": "ShortestAverageSentenceLength",
            "type": "number"
        },
        {
            "name": "LongestAverageSentenceLength",
            "baseName": "LongestAverageSentenceLength",
            "type": "number"
        },
        {
            "name": "LongestIndividualSentence",
            "baseName": "LongestIndividualSentence",
            "type": "number"
        },
        {
            "name": "HighestPassiveIndex",
            "baseName": "HighestPassiveIndex",
            "type": "number"
        },
        {
            "name": "MaxGlueIndex",
            "baseName": "MaxGlueIndex",
            "type": "number"
        },
        {
            "name": "MinSentenceVariety",
            "baseName": "MinSentenceVariety",
            "type": "number"
        },
        {
            "name": "HighestPronounPercentage",
            "baseName": "HighestPronounPercentage",
            "type": "number"
        },
        {
            "name": "LowestPronounPercentage",
            "baseName": "LowestPronounPercentage",
            "type": "number"
        },
        {
            "name": "HighestAcademicPronounPercentage",
            "baseName": "HighestAcademicPronounPercentage",
            "type": "number"
        },
        {
            "name": "HighestInitialPronounPercentage",
            "baseName": "HighestInitialPronounPercentage",
            "type": "number"
        },
        {
            "name": "LowestInitialPronounPercentage",
            "baseName": "LowestInitialPronounPercentage",
            "type": "number"
        },
        {
            "name": "LowestWeWeScore",
            "baseName": "LowestWeWeScore",
            "type": "number"
        },
        {
            "name": "LongestAverageParagraphLength",
            "baseName": "LongestAverageParagraphLength",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AnalysisSettings.attributeTypeMap;
    }
}

/**
* Represents report summary
*/
export class AnalysisSummary {
    /**
    * Report's display name
    */
    'ReportDisplayName'?: string;
    /**
    * Report's ID
    */
    'ReportName'?: string;
    /**
    * Found issues
    */
    'SummaryItems'?: Array<AnalysisSummaryItem>;
    /**
    * Number of found issues
    */
    'NumberOfIssues'?: number;
    /**
    * Short report description
    */
    'ReportDescription'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ReportDisplayName",
            "baseName": "ReportDisplayName",
            "type": "string"
        },
        {
            "name": "ReportName",
            "baseName": "ReportName",
            "type": "string"
        },
        {
            "name": "SummaryItems",
            "baseName": "SummaryItems",
            "type": "Array<AnalysisSummaryItem>"
        },
        {
            "name": "NumberOfIssues",
            "baseName": "NumberOfIssues",
            "type": "number"
        },
        {
            "name": "ReportDescription",
            "baseName": "ReportDescription",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AnalysisSummary.attributeTypeMap;
    }
}

export class AnalysisSummaryGraph {
    'Name'?: string;
    'Items'?: Array<AnalysisSummaryGraphItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "Items",
            "baseName": "Items",
            "type": "Array<AnalysisSummaryGraphItem>"
        }    ];

    static getAttributeTypeMap() {
        return AnalysisSummaryGraph.attributeTypeMap;
    }
}

export class AnalysisSummaryGraphItem {
    'Label'?: string;
    'Color'?: string;
    'Length'?: number;
    'SubCategory'?: string;
    'Index'?: number;
    'Id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Label",
            "baseName": "Label",
            "type": "string"
        },
        {
            "name": "Color",
            "baseName": "Color",
            "type": "string"
        },
        {
            "name": "Length",
            "baseName": "Length",
            "type": "number"
        },
        {
            "name": "SubCategory",
            "baseName": "SubCategory",
            "type": "string"
        },
        {
            "name": "Index",
            "baseName": "Index",
            "type": "number"
        },
        {
            "name": "Id",
            "baseName": "Id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AnalysisSummaryGraphItem.attributeTypeMap;
    }
}

export class AnalysisSummaryItem {
    'Text'?: string;
    'Graph'?: AnalysisSummaryGraph;
    'Url'?: string;
    'UrlText'?: string;
    'SubItems'?: Array<AnalysisSummarySubItem>;
    'IsPositive'?: AnalysisSummaryItem.IsPositiveEnum;
    'Category'?: SuggestionCategory;
    'CategoryName'?: string;
    'NumIssues'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        },
        {
            "name": "Graph",
            "baseName": "Graph",
            "type": "AnalysisSummaryGraph"
        },
        {
            "name": "Url",
            "baseName": "Url",
            "type": "string"
        },
        {
            "name": "UrlText",
            "baseName": "UrlText",
            "type": "string"
        },
        {
            "name": "SubItems",
            "baseName": "SubItems",
            "type": "Array<AnalysisSummarySubItem>"
        },
        {
            "name": "IsPositive",
            "baseName": "IsPositive",
            "type": "AnalysisSummaryItem.IsPositiveEnum"
        },
        {
            "name": "Category",
            "baseName": "Category",
            "type": "SuggestionCategory"
        },
        {
            "name": "CategoryName",
            "baseName": "CategoryName",
            "type": "string"
        },
        {
            "name": "NumIssues",
            "baseName": "NumIssues",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AnalysisSummaryItem.attributeTypeMap;
    }
}

export namespace AnalysisSummaryItem {
    export enum IsPositiveEnum {
        Positive = <any> 'Positive',
        Negative = <any> 'Negative',
        Information = <any> 'Information'
    }
}
export class AnalysisSummarySubItem {
    'TagIds'?: Array<string>;
    'Text'?: string;
    'SuggestionCategory'?: string;
    'SubCategory'?: string;
    'SearchTerm'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TagIds",
            "baseName": "TagIds",
            "type": "Array<string>"
        },
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        },
        {
            "name": "SuggestionCategory",
            "baseName": "SuggestionCategory",
            "type": "string"
        },
        {
            "name": "SubCategory",
            "baseName": "SubCategory",
            "type": "string"
        },
        {
            "name": "SearchTerm",
            "baseName": "SearchTerm",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AnalysisSummarySubItem.attributeTypeMap;
    }
}

/**
* Asynchronous request
*/
export class AsyncResponseContextualThesaurusResponse {
    /**
    * Async task Id. Empty or null if task was processed synchronously
    */
    'TaskId'?: string;
    /**
    * Actual response
    */
    'Result'?: ContextualThesaurusResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TaskId",
            "baseName": "TaskId",
            "type": "string"
        },
        {
            "name": "Result",
            "baseName": "Result",
            "type": "ContextualThesaurusResponse"
        }    ];

    static getAttributeTypeMap() {
        return AsyncResponseContextualThesaurusResponse.attributeTypeMap;
    }
}

/**
* Asynchronous request
*/
export class AsyncResponseHtmlAnalysisResponse {
    /**
    * Async task Id. Empty or null if task was processed synchronously
    */
    'TaskId'?: string;
    /**
    * Actual response
    */
    'Result'?: HtmlAnalysisResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TaskId",
            "baseName": "TaskId",
            "type": "string"
        },
        {
            "name": "Result",
            "baseName": "Result",
            "type": "HtmlAnalysisResponse"
        }    ];

    static getAttributeTypeMap() {
        return AsyncResponseHtmlAnalysisResponse.attributeTypeMap;
    }
}

/**
* Asynchronous request
*/
export class AsyncResponseSummaryAnalysisResponse {
    /**
    * Async task Id. Empty or null if task was processed synchronously
    */
    'TaskId'?: string;
    /**
    * Actual response
    */
    'Result'?: SummaryAnalysisResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TaskId",
            "baseName": "TaskId",
            "type": "string"
        },
        {
            "name": "Result",
            "baseName": "Result",
            "type": "SummaryAnalysisResponse"
        }    ];

    static getAttributeTypeMap() {
        return AsyncResponseSummaryAnalysisResponse.attributeTypeMap;
    }
}

/**
* Asynchronous request
*/
export class AsyncResponseTextAnalysisResponse {
    /**
    * Async task Id. Empty or null if task was processed synchronously
    */
    'TaskId'?: string;
    /**
    * Actual response
    */
    'Result'?: TextAnalysisResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TaskId",
            "baseName": "TaskId",
            "type": "string"
        },
        {
            "name": "Result",
            "baseName": "Result",
            "type": "TextAnalysisResponse"
        }    ];

    static getAttributeTypeMap() {
        return AsyncResponseTextAnalysisResponse.attributeTypeMap;
    }
}

/**
* Asynchronous request
*/
export class AsyncResponseWordCloudResponse {
    /**
    * Async task Id. Empty or null if task was processed synchronously
    */
    'TaskId'?: string;
    /**
    * Actual response
    */
    'Result'?: WordCloudResponse;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "TaskId",
            "baseName": "TaskId",
            "type": "string"
        },
        {
            "name": "Result",
            "baseName": "Result",
            "type": "WordCloudResponse"
        }    ];

    static getAttributeTypeMap() {
        return AsyncResponseWordCloudResponse.attributeTypeMap;
    }
}

export class ContextualThesaurusRequest {
    /**
    * the word for the thesaurus call with surrounding context
    */
    'Context': string;
    /**
    * the start position of the word to get suggestions for. 0 based
    */
    'ContextStart': number;
    /**
    * the end position of the word to get suggestions for. 0 based. Would be the same as the start pos for a 1 letter word
    */
    'ContextEnd': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Context",
            "baseName": "Context",
            "type": "string"
        },
        {
            "name": "ContextStart",
            "baseName": "ContextStart",
            "type": "number"
        },
        {
            "name": "ContextEnd",
            "baseName": "ContextEnd",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ContextualThesaurusRequest.attributeTypeMap;
    }
}

export class ContextualThesaurusResponse {
    /**
    * List of context-specific suggestions
    */
    'Suggestions'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Suggestions",
            "baseName": "Suggestions",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ContextualThesaurusResponse.attributeTypeMap;
    }
}

export class DocTag {
    /**
    * The start position of the suggestion. 0 based
    */
    'startPos': number;
    /**
    * The end position of the suggestion. 0 based
    */
    'endPos': number;
    /**
    * Report Id
    */
    'report'?: string;
    /**
    * List of source documents found by plagiarism checker
    */
    'urls'?: Array<string>;
    /**
    * Suggestion's category
    */
    'category'?: string;
    /**
    * Suggetsion's category display name
    */
    'categoryDisplayName'?: string;
    /**
    * Suggestion's subcategory
    */
    'subcategory'?: string;
    /**
    * Short suggestion's description
    */
    'hint'?: string;
    /**
    * List of possible replacements
    */
    'suggestions'?: Array<string>;
    /**
    * Identifies that this suggestion is a part of larger one
    */
    'isSubTag': boolean;
    /**
    * TODO DOCS
    */
    'helpId'?: string;
    /**
    * Suggestion's Id
    */
    'id'?: string;
    /**
    * Is tag invisible?
    */
    'invisible'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startPos",
            "baseName": "startPos",
            "type": "number"
        },
        {
            "name": "endPos",
            "baseName": "endPos",
            "type": "number"
        },
        {
            "name": "report",
            "baseName": "report",
            "type": "string"
        },
        {
            "name": "urls",
            "baseName": "urls",
            "type": "Array<string>"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "categoryDisplayName",
            "baseName": "categoryDisplayName",
            "type": "string"
        },
        {
            "name": "subcategory",
            "baseName": "subcategory",
            "type": "string"
        },
        {
            "name": "hint",
            "baseName": "hint",
            "type": "string"
        },
        {
            "name": "suggestions",
            "baseName": "suggestions",
            "type": "Array<string>"
        },
        {
            "name": "isSubTag",
            "baseName": "isSubTag",
            "type": "boolean"
        },
        {
            "name": "helpId",
            "baseName": "helpId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "invisible",
            "baseName": "invisible",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DocTag.attributeTypeMap;
    }
}

/**
* Thesaurus meaning in one context
*/
export class EntryMeaning {
    'Meaning'?: string;
    'PartOfSpeech'?: string;
    'Synonyms'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Meaning",
            "baseName": "Meaning",
            "type": "string"
        },
        {
            "name": "PartOfSpeech",
            "baseName": "PartOfSpeech",
            "type": "string"
        },
        {
            "name": "Synonyms",
            "baseName": "Synonyms",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return EntryMeaning.attributeTypeMap;
    }
}

/**
* ## Available Reports  Below is a list of the currently available reports from ProWritingAid. If you would like a different report, or require extra information, such as tokenization, sentence split, parts of speech, etc. then please [get in touch](https://prowritingaid.com/en/Home/Contact).    Report Name | Status | Description  ------------ | ------------- | -------------  acronym | Live | Shows all the acronyms in your writing and highlights where they haven't been defined, or have been defined after the first occurrence, or have been defined multiple times.. |  alliteration | Live | Highlights alliterations in your writing. Alliterations are a linguistic tool used by some writers for effect.. |  allrepeats | Development | Highlights words and phrases that you've used repeatedly in your text. |  allsentences | Live | Shows a visual representation of the sentences lengths of your writing. Try and vary the sentence lengths to maintain the interest of the reader.. |  bully | Development | Highlights bullying and vulgar language in your text.. |  cliche | Live | Scours your work for cliches and highlights them. Nobody likes to read a cliche so best to avoid them. Redundant expressions can also be removed as they say the same thing twice.. |  closerepeat | Development | Highlights any words and phrases that you have repeated within a short space of writing. Try and think of something else to say.. |  complex | Live | Highlights complex words in your writing. Words are broken down by number of syllables.. |  consistency | Live | Highlights inconsistency in your text. Picking up inconsistencies in your text can be one of the hardest editing tasks.. |  core | Development | Core findings. |  coreplus | Development | Core findings. |  corporate | Live | Highlights uses of corporate wording that can be simplified to clarify your document.. |  dialog | Live | Highlights the dialogue tags in your text. Editors prefer minimal use of all dialogue tags (except for 'said').. |  diction | Live | Provides a list of possible diction problems and suggestions on how you might revise them.. |  dva | Live | Highlights diction problems, vague and abstract words in your text.. |  eloquence | Live | Designed to help you develop your use of stylistic writing techniques such as alliteration, epistrophe, and hendiadys. The items in this report are not suggestions, just aids to help you along the way.. |  grammar | Live | Checks your text for grammar errors and potential word mis-use.. |  grammarplus | Live | Checks your text for grammar errors and potential word mis-use.. |  homonym | Live | Helps you check for incorrect word usage. Homonyms are words which sound alike yet are spelled differently. For example: there, their and they're or raw and roar.. |  house | Development | A blank report for you to create your own patterns in. Ideal for a house style. Go to the settings screen to set-up your own patterns. . |  initial | Live | Highlights the initial pronouns in your text. Repetitive use of initial pronouns can lead to boring text, e.g. He did this. He did that. He did another thing.. |  nlp | Development | Our NLP Predicate Words report allows you to easily identify the key modality or representation system of a piece of text. If you are analyzing a document written by someone else then this will give you an idea of their preferred representational system. This may help you tailor your writing in order to build rapport. If you don't know the modality of your reader then try to use a balance of words from each modality. This will broaden the appeal of your writing.. |  overused | Live | Compares the frequency of commonly overused words in your text to published writing to give you an indication of where you may be over-using words.. |  overusedonly | Live | Compares the frequency of commonly overused words in your text to published writing to give you an indication of where you may be over-using words.. |  overview | Live | Gives you an overview of the key metrics for your document.. |  pacing | Live | Identifies the slower paced parts of your manuscript, such as introspection and backstory so you can spread them out. Try not to have too many slower paced paragraphs in a row as this can get boring.. |  paragraph_readability | Live | Shows you the relative readability of each paragraph in your text.. |  passive | Live | Highlights areas where your writing style might be improved, such as use of passive and hidden verbs.. |  phrases | Live | Provides a summary of all the phrases that you have repeated in your writing. Try and cut down on repeats.. |  plagiarism | Live | Identifies parts of your text that occur in other documents. Scans millions of web-pages, books, and academic papers.. |  plength | Live | A visual representation of the paragraph lengths of your writing. Avoid writing more than five or six sentences in a paragraph. Also try to avoid too many short paragraphs.. |  preadability | Live | Provides a series of readability measures for your text so you can determine if it is suitable for your intended audience.. |  readability | Live | Provides a series of readability measures for your text so you can determine if it is suitable for your intended audience.. |  sentiment | Live | Shows a histogram of the sentiment in your story so you can monitor large swings.. |  sentimentwords | Development | Highlights words that have a sentiment bias in your text, and grades them.. |  seo | Development | Shows how yout text can be optimized to appear higher in Google rankings.. |  slength | Live | Shows a visual representation of the sentences lengths of your writing. Try and vary the sentence lengths to maintain the interest of the reader.. |  ssentences | Live | Shows sticky sentences in your writing. Sticky sentences slow your reader down; try to avoid them.. |  ssentences_noglue | Live | Shows sticky sentences in your writing. Sticky sentences slow your reader down; try to avoid them.. |  structure | Live | Highlights the key structure of a document such as sentences and paragraphs.. |  thesaurus | Beta | Shows possible replacements for nouns, verbs, adjectives and adverbs.. |  time | Live | Highlights any temporal references in your text so you can check for inconsistency and view the time-line of your text.. |  topics | Live | Suggested topics that are related to the subject matter of your text.. |  transition | Live | Highlights the transitions in your report. Transitions help organize ideas. Writing that is short on transitions is often hard to follow. Non-fiction writing that has under 1 transition per 4 sentences tends to be less understandable.. |  vague | Live | Provides a list of words that may be considered vague or abstract. Consider strengthening them.. |  wordcloud | Live | Shows you a word cloud of the most commonly occuring words in your text.. |  wordsandphrases | Deprecated | Highlights any words and phrases that you have repeated within a short space of writing. Try and think of something else to say.. |  wordsphrases | Live | Highlights any words and phrases that you have repeated within a short space of writing. Try and think of something else to say.. |
*/
export class HtmlAnalysisRequest {
    /**
    * Html to be processed
    */
    'Html': string;
    /**
    * List of reports - EXAMPLE: [\"grammar\",\"overused\"]
    */
    'Reports': Array<string>;
    /**
    * Document's writing style
    */
    'Style': HtmlAnalysisRequest.StyleEnum;
    /**
    * Document's language. Set correct UK/US language to get region-specific suggestions
    */
    'Language': HtmlAnalysisRequest.LanguageEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Html",
            "baseName": "Html",
            "type": "string"
        },
        {
            "name": "Reports",
            "baseName": "Reports",
            "type": "Array<string>"
        },
        {
            "name": "Style",
            "baseName": "Style",
            "type": "HtmlAnalysisRequest.StyleEnum"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "HtmlAnalysisRequest.LanguageEnum"
        }    ];

    static getAttributeTypeMap() {
        return HtmlAnalysisRequest.attributeTypeMap;
    }
}

export namespace HtmlAnalysisRequest {
    export enum StyleEnum {
        NotSet = <any> 'NotSet',
        General = <any> 'General',
        Academic = <any> 'Academic',
        Business = <any> 'Business',
        Technical = <any> 'Technical',
        Creative = <any> 'Creative',
        Casual = <any> 'Casual',
        Web = <any> 'Web'
    }
    export enum LanguageEnum {
        EnUS = <any> 'en_US',
        EnUK = <any> 'en_UK',
        En = <any> 'en',
        Es = <any> 'es'
    }
}
export class HtmlAnalysisResponse {
    /**
    * Result in form of html. Contains tags with meta-information
    */
    'Html': string;
    /**
    * Number of processed words
    */
    'WordCount': number;
    /**
    * 
    */
    'Summaries': Array<AnalysisSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Html",
            "baseName": "Html",
            "type": "string"
        },
        {
            "name": "WordCount",
            "baseName": "WordCount",
            "type": "number"
        },
        {
            "name": "Summaries",
            "baseName": "Summaries",
            "type": "Array<AnalysisSummary>"
        }    ];

    static getAttributeTypeMap() {
        return HtmlAnalysisResponse.attributeTypeMap;
    }
}

export class SuggestionCategory {
    'Name'?: string;
    'DisplayName'?: string;
    'Description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "DisplayName",
            "baseName": "DisplayName",
            "type": "string"
        },
        {
            "name": "Description",
            "baseName": "Description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SuggestionCategory.attributeTypeMap;
    }
}

export class SummaryAnalysisRequest {
    /**
    * Text to be analyzed
    */
    'Text': string;
    /**
    * Analysis settings
    */
    'Settings': AnalysisSettings;
    /**
    * Document's writing style
    */
    'Style': SummaryAnalysisRequest.StyleEnum;
    /**
    * Document's language. Set correct UK/US language to get region-specific suggestions
    */
    'Language': SummaryAnalysisRequest.LanguageEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        },
        {
            "name": "Settings",
            "baseName": "Settings",
            "type": "AnalysisSettings"
        },
        {
            "name": "Style",
            "baseName": "Style",
            "type": "SummaryAnalysisRequest.StyleEnum"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "SummaryAnalysisRequest.LanguageEnum"
        }    ];

    static getAttributeTypeMap() {
        return SummaryAnalysisRequest.attributeTypeMap;
    }
}

export namespace SummaryAnalysisRequest {
    export enum StyleEnum {
        NotSet = <any> 'NotSet',
        General = <any> 'General',
        Academic = <any> 'Academic',
        Business = <any> 'Business',
        Technical = <any> 'Technical',
        Creative = <any> 'Creative',
        Casual = <any> 'Casual',
        Web = <any> 'Web'
    }
    export enum LanguageEnum {
        EnUS = <any> 'en_US',
        EnUK = <any> 'en_UK',
        En = <any> 'en',
        Es = <any> 'es'
    }
}
export class SummaryAnalysisResponse {
    /**
    * SUmmary report renderred as html
    */
    'Text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SummaryAnalysisResponse.attributeTypeMap;
    }
}

/**
* ## Available Reports  Below is a list of the currently available reports from ProWritingAid. If you would like a different report, or require extra information, such as tokenization, sentence split, parts of speech, etc. then please [get in touch](https://prowritingaid.com/en/Home/Contact).    Report Name | Status | Description  ------------ | ------------- | -------------  acronym | Live | Shows all the acronyms in your writing and highlights where they haven't been defined, or have been defined after the first occurrence, or have been defined multiple times.. |  alliteration | Live | Highlights alliterations in your writing. Alliterations are a linguistic tool used by some writers for effect.. |  allrepeats | Development | Highlights words and phrases that you've used repeatedly in your text. |  allsentences | Live | Shows a visual representation of the sentences lengths of your writing. Try and vary the sentence lengths to maintain the interest of the reader.. |  bully | Development | Highlights bullying and vulgar language in your text.. |  cliche | Live | Scours your work for cliches and highlights them. Nobody likes to read a cliche so best to avoid them. Redundant expressions can also be removed as they say the same thing twice.. |  closerepeat | Development | Highlights any words and phrases that you have repeated within a short space of writing. Try and think of something else to say.. |  complex | Live | Highlights complex words in your writing. Words are broken down by number of syllables.. |  consistency | Live | Highlights inconsistency in your text. Picking up inconsistencies in your text can be one of the hardest editing tasks.. |  core | Development | Core findings. |  coreplus | Development | Core findings. |  corporate | Live | Highlights uses of corporate wording that can be simplified to clarify your document.. |  dialog | Live | Highlights the dialogue tags in your text. Editors prefer minimal use of all dialogue tags (except for 'said').. |  diction | Live | Provides a list of possible diction problems and suggestions on how you might revise them.. |  dva | Live | Highlights diction problems, vague and abstract words in your text.. |  eloquence | Live | Designed to help you develop your use of stylistic writing techniques such as alliteration, epistrophe, and hendiadys. The items in this report are not suggestions, just aids to help you along the way.. |  grammar | Live | Checks your text for grammar errors and potential word mis-use.. |  grammarplus | Live | Checks your text for grammar errors and potential word mis-use.. |  homonym | Live | Helps you check for incorrect word usage. Homonyms are words which sound alike yet are spelled differently. For example: there, their and they're or raw and roar.. |  house | Development | A blank report for you to create your own patterns in. Ideal for a house style. Go to the settings screen to set-up your own patterns. . |  initial | Live | Highlights the initial pronouns in your text. Repetitive use of initial pronouns can lead to boring text, e.g. He did this. He did that. He did another thing.. |  nlp | Development | Our NLP Predicate Words report allows you to easily identify the key modality or representation system of a piece of text. If you are analyzing a document written by someone else then this will give you an idea of their preferred representational system. This may help you tailor your writing in order to build rapport. If you don't know the modality of your reader then try to use a balance of words from each modality. This will broaden the appeal of your writing.. |  overused | Live | Compares the frequency of commonly overused words in your text to published writing to give you an indication of where you may be over-using words.. |  overusedonly | Live | Compares the frequency of commonly overused words in your text to published writing to give you an indication of where you may be over-using words.. |  overview | Live | Gives you an overview of the key metrics for your document.. |  pacing | Live | Identifies the slower paced parts of your manuscript, such as introspection and backstory so you can spread them out. Try not to have too many slower paced paragraphs in a row as this can get boring.. |  paragraph_readability | Live | Shows you the relative readability of each paragraph in your text.. |  passive | Live | Highlights areas where your writing style might be improved, such as use of passive and hidden verbs.. |  phrases | Live | Provides a summary of all the phrases that you have repeated in your writing. Try and cut down on repeats.. |  plagiarism | Live | Identifies parts of your text that occur in other documents. Scans millions of web-pages, books, and academic papers.. |  plength | Live | A visual representation of the paragraph lengths of your writing. Avoid writing more than five or six sentences in a paragraph. Also try to avoid too many short paragraphs.. |  preadability | Live | Provides a series of readability measures for your text so you can determine if it is suitable for your intended audience.. |  readability | Live | Provides a series of readability measures for your text so you can determine if it is suitable for your intended audience.. |  sentiment | Live | Shows a histogram of the sentiment in your story so you can monitor large swings.. |  sentimentwords | Development | Highlights words that have a sentiment bias in your text, and grades them.. |  seo | Development | Shows how yout text can be optimized to appear higher in Google rankings.. |  slength | Live | Shows a visual representation of the sentences lengths of your writing. Try and vary the sentence lengths to maintain the interest of the reader.. |  ssentences | Live | Shows sticky sentences in your writing. Sticky sentences slow your reader down; try to avoid them.. |  ssentences_noglue | Live | Shows sticky sentences in your writing. Sticky sentences slow your reader down; try to avoid them.. |  structure | Live | Highlights the key structure of a document such as sentences and paragraphs.. |  thesaurus | Beta | Shows possible replacements for nouns, verbs, adjectives and adverbs.. |  time | Live | Highlights any temporal references in your text so you can check for inconsistency and view the time-line of your text.. |  topics | Live | Suggested topics that are related to the subject matter of your text.. |  transition | Live | Highlights the transitions in your report. Transitions help organize ideas. Writing that is short on transitions is often hard to follow. Non-fiction writing that has under 1 transition per 4 sentences tends to be less understandable.. |  vague | Live | Provides a list of words that may be considered vague or abstract. Consider strengthening them.. |  wordcloud | Live | Shows you a word cloud of the most commonly occuring words in your text.. |  wordsandphrases | Deprecated | Highlights any words and phrases that you have repeated within a short space of writing. Try and think of something else to say.. |  wordsphrases | Live | Highlights any words and phrases that you have repeated within a short space of writing. Try and think of something else to say.. |
*/
export class TextAnalysisRequest {
    /**
    * Text to be processed
    */
    'Text': string;
    /**
    * List of reports - EXAMPLE: [\"grammar\",\"overused\"]
    */
    'Reports': Array<string>;
    /**
    * Document's writing style
    */
    'Style': TextAnalysisRequest.StyleEnum;
    /**
    * Document's language. Set correct UK/US language to get region-specific suggestions
    */
    'Language': TextAnalysisRequest.LanguageEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        },
        {
            "name": "Reports",
            "baseName": "Reports",
            "type": "Array<string>"
        },
        {
            "name": "Style",
            "baseName": "Style",
            "type": "TextAnalysisRequest.StyleEnum"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "TextAnalysisRequest.LanguageEnum"
        }    ];

    static getAttributeTypeMap() {
        return TextAnalysisRequest.attributeTypeMap;
    }
}

export namespace TextAnalysisRequest {
    export enum StyleEnum {
        NotSet = <any> 'NotSet',
        General = <any> 'General',
        Academic = <any> 'Academic',
        Business = <any> 'Business',
        Technical = <any> 'Technical',
        Creative = <any> 'Creative',
        Casual = <any> 'Casual',
        Web = <any> 'Web'
    }
    export enum LanguageEnum {
        EnUS = <any> 'en_US',
        EnUK = <any> 'en_UK',
        En = <any> 'en',
        Es = <any> 'es'
    }
}
export class TextAnalysisResponse {
    /**
    * List of found suggestions
    */
    'Tags': Array<DocTag>;
    /**
    * Number of processed words
    */
    'WordCount': number;
    /**
    * 
    */
    'Summaries': Array<AnalysisSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Tags",
            "baseName": "Tags",
            "type": "Array<DocTag>"
        },
        {
            "name": "WordCount",
            "baseName": "WordCount",
            "type": "number"
        },
        {
            "name": "Summaries",
            "baseName": "Summaries",
            "type": "Array<AnalysisSummary>"
        }    ];

    static getAttributeTypeMap() {
        return TextAnalysisResponse.attributeTypeMap;
    }
}

export class ThesaurusRequest {
    /**
    * the word for the thesaurus call
    */
    'Word': string;
    /**
    * the language used
    */
    'Language': ThesaurusRequest.LanguageEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Word",
            "baseName": "Word",
            "type": "string"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "ThesaurusRequest.LanguageEnum"
        }    ];

    static getAttributeTypeMap() {
        return ThesaurusRequest.attributeTypeMap;
    }
}

export namespace ThesaurusRequest {
    export enum LanguageEnum {
        EnUS = <any> 'en_US',
        EnUK = <any> 'en_UK',
        En = <any> 'en',
        Es = <any> 'es'
    }
}
export class ThesaurusResponse {
    /**
    * The word that was searched
    */
    'Word'?: string;
    /**
    * List of context-specific meanings
    */
    'Meanings'?: Array<EntryMeaning>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Word",
            "baseName": "Word",
            "type": "string"
        },
        {
            "name": "Meanings",
            "baseName": "Meanings",
            "type": "Array<EntryMeaning>"
        }    ];

    static getAttributeTypeMap() {
        return ThesaurusResponse.attributeTypeMap;
    }
}

export class WordCloudRequest {
    /**
    * The text to be turned into a Word Cloud
    */
    'Text': string;
    /**
    * The orientation of the text
    */
    'Orientation': WordCloudRequest.OrientationEnum;
    /**
    * The method to be used for casing
    */
    'CaseMethod': WordCloudRequest.CaseMethodEnum;
    /**
    * The name of the palette
    */
    'PaletteName': string;
    /**
    * the maximum number of words to be created
    */
    'MaximumWordCount': number;
    /**
    * Should Common words be removed from the cloud
    */
    'RemoveCommonWords': boolean;
    /**
    * The name of the font to use
    */
    'FontName': string;
    /**
    * The width of the image to produce
    */
    'Width': number;
    /**
    * The height of the image to produce
    */
    'Height': number;
    /**
    * Only use the sentiment words from the text
    */
    'OnlySentimentWords': boolean;
    /**
    * Document's writing style
    */
    'Style': WordCloudRequest.StyleEnum;
    /**
    * Document's language. Set correct UK/US language to get region-specific suggestions
    */
    'Language': WordCloudRequest.LanguageEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Text",
            "baseName": "Text",
            "type": "string"
        },
        {
            "name": "Orientation",
            "baseName": "Orientation",
            "type": "WordCloudRequest.OrientationEnum"
        },
        {
            "name": "CaseMethod",
            "baseName": "CaseMethod",
            "type": "WordCloudRequest.CaseMethodEnum"
        },
        {
            "name": "PaletteName",
            "baseName": "PaletteName",
            "type": "string"
        },
        {
            "name": "MaximumWordCount",
            "baseName": "MaximumWordCount",
            "type": "number"
        },
        {
            "name": "RemoveCommonWords",
            "baseName": "RemoveCommonWords",
            "type": "boolean"
        },
        {
            "name": "FontName",
            "baseName": "FontName",
            "type": "string"
        },
        {
            "name": "Width",
            "baseName": "Width",
            "type": "number"
        },
        {
            "name": "Height",
            "baseName": "Height",
            "type": "number"
        },
        {
            "name": "OnlySentimentWords",
            "baseName": "OnlySentimentWords",
            "type": "boolean"
        },
        {
            "name": "Style",
            "baseName": "Style",
            "type": "WordCloudRequest.StyleEnum"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "WordCloudRequest.LanguageEnum"
        }    ];

    static getAttributeTypeMap() {
        return WordCloudRequest.attributeTypeMap;
    }
}

export namespace WordCloudRequest {
    export enum OrientationEnum {
        Horizontal = <any> 'Horizontal',
        MostlyHorizontal = <any> 'MostlyHorizontal',
        Vertical = <any> 'Vertical',
        MostlyVertical = <any> 'MostlyVertical',
        HalfAndHalf = <any> 'HalfAndHalf',
        EveryWhichWay = <any> 'EveryWhichWay'
    }
    export enum CaseMethodEnum {
        PreserveCase = <any> 'PreserveCase',
        Lowercase = <any> 'Lowercase',
        Uppercase = <any> 'Uppercase',
        IntelligentCase = <any> 'IntelligentCase'
    }
    export enum StyleEnum {
        NotSet = <any> 'NotSet',
        General = <any> 'General',
        Academic = <any> 'Academic',
        Business = <any> 'Business',
        Technical = <any> 'Technical',
        Creative = <any> 'Creative',
        Casual = <any> 'Casual',
        Web = <any> 'Web'
    }
    export enum LanguageEnum {
        EnUS = <any> 'en_US',
        EnUK = <any> 'en_UK',
        En = <any> 'en',
        Es = <any> 'es'
    }
}
export class WordCloudResponse {
    /**
    * the URL of the Word Cloud
    */
    'Url': string;
    /**
    * The detected language of the text
    */
    'Language'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "Url",
            "baseName": "Url",
            "type": "string"
        },
        {
            "name": "Language",
            "baseName": "Language",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WordCloudResponse.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "AnalysisSummaryItem.IsPositiveEnum": AnalysisSummaryItem.IsPositiveEnum,
        "HtmlAnalysisRequest.StyleEnum": HtmlAnalysisRequest.StyleEnum,
        "HtmlAnalysisRequest.LanguageEnum": HtmlAnalysisRequest.LanguageEnum,
        "SummaryAnalysisRequest.StyleEnum": SummaryAnalysisRequest.StyleEnum,
        "SummaryAnalysisRequest.LanguageEnum": SummaryAnalysisRequest.LanguageEnum,
        "TextAnalysisRequest.StyleEnum": TextAnalysisRequest.StyleEnum,
        "TextAnalysisRequest.LanguageEnum": TextAnalysisRequest.LanguageEnum,
        "ThesaurusRequest.LanguageEnum": ThesaurusRequest.LanguageEnum,
        "WordCloudRequest.OrientationEnum": WordCloudRequest.OrientationEnum,
        "WordCloudRequest.CaseMethodEnum": WordCloudRequest.CaseMethodEnum,
        "WordCloudRequest.StyleEnum": WordCloudRequest.StyleEnum,
        "WordCloudRequest.LanguageEnum": WordCloudRequest.LanguageEnum,
}

let typeMap: {[index: string]: any} = {
    "AnalysisSettings": AnalysisSettings,
    "AnalysisSummary": AnalysisSummary,
    "AnalysisSummaryGraph": AnalysisSummaryGraph,
    "AnalysisSummaryGraphItem": AnalysisSummaryGraphItem,
    "AnalysisSummaryItem": AnalysisSummaryItem,
    "AnalysisSummarySubItem": AnalysisSummarySubItem,
    "AsyncResponseContextualThesaurusResponse": AsyncResponseContextualThesaurusResponse,
    "AsyncResponseHtmlAnalysisResponse": AsyncResponseHtmlAnalysisResponse,
    "AsyncResponseSummaryAnalysisResponse": AsyncResponseSummaryAnalysisResponse,
    "AsyncResponseTextAnalysisResponse": AsyncResponseTextAnalysisResponse,
    "AsyncResponseWordCloudResponse": AsyncResponseWordCloudResponse,
    "ContextualThesaurusRequest": ContextualThesaurusRequest,
    "ContextualThesaurusResponse": ContextualThesaurusResponse,
    "DocTag": DocTag,
    "EntryMeaning": EntryMeaning,
    "HtmlAnalysisRequest": HtmlAnalysisRequest,
    "HtmlAnalysisResponse": HtmlAnalysisResponse,
    "SuggestionCategory": SuggestionCategory,
    "SummaryAnalysisRequest": SummaryAnalysisRequest,
    "SummaryAnalysisResponse": SummaryAnalysisResponse,
    "TextAnalysisRequest": TextAnalysisRequest,
    "TextAnalysisResponse": TextAnalysisResponse,
    "ThesaurusRequest": ThesaurusRequest,
    "ThesaurusResponse": ThesaurusResponse,
    "WordCloudRequest": WordCloudRequest,
    "WordCloudResponse": WordCloudResponse,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum ContextualThesaurusApiApiKeys {
    licenseCode,
}

export class ContextualThesaurusApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'licenseCode': new ApiKeyAuth('header', 'licenseCode'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ContextualThesaurusApiApiKeys, value: string) {
        (this.authentications as any)[ContextualThesaurusApiApiKeys[key]].apiKey = value;
    }
    /**
     * Tries to get the result of a request using the task id of the request
     * @summary Tries to get the result of a request using the task id of the request
     * @param taskId 
     */
    public get (taskId: string) : Promise<{ response: http.ClientResponse; body: AsyncResponseContextualThesaurusResponse;  }> {
        const localVarPath = this.basePath + '/api/async/contextualthesaurus/result/{taskId}'
            .replace('{' + 'taskId' + '}', encodeURIComponent(String(taskId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'taskId' is not null or undefined
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.licenseCode.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AsyncResponseContextualThesaurusResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AsyncResponseContextualThesaurusResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Analyses text and returns contextual thesaurus entries
     * @summary Analyses text and returns contextual thesaurus entries
     * @param requestp 
     */
    public post (requestp: ContextualThesaurusRequest) : Promise<{ response: http.ClientResponse; body: AsyncResponseContextualThesaurusResponse;  }> {
        const localVarPath = this.basePath + '/api/async/contextualthesaurus';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestp' is not null or undefined
        if (requestp === null || requestp === undefined) {
            throw new Error('Required parameter requestp was null or undefined when calling post.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestp, "ContextualThesaurusRequest")
        };

        this.authentications.licenseCode.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AsyncResponseContextualThesaurusResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AsyncResponseContextualThesaurusResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HtmlApiApiKeys {
    licenseCode,
}

export class HtmlApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'licenseCode': new ApiKeyAuth('header', 'licenseCode'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HtmlApiApiKeys, value: string) {
        (this.authentications as any)[HtmlApiApiKeys[key]].apiKey = value;
    }
    /**
     * Tries to get the result of a request using the task id of the request
     * @summary Tries to get the result of a request using the task id of the request
     * @param taskId 
     */
    public get (taskId: string) : Promise<{ response: http.ClientResponse; body: AsyncResponseHtmlAnalysisResponse;  }> {
        const localVarPath = this.basePath + '/api/async/html/result/{taskId}'
            .replace('{' + 'taskId' + '}', encodeURIComponent(String(taskId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'taskId' is not null or undefined
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.licenseCode.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AsyncResponseHtmlAnalysisResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AsyncResponseHtmlAnalysisResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * @summary Analyses HTML and adds suggestion tags to it
     * @param requestp 
     */
    public post (requestp: HtmlAnalysisRequest) : Promise<{ response: http.ClientResponse; body: AsyncResponseHtmlAnalysisResponse;  }> {
        const localVarPath = this.basePath + '/api/async/html';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestp' is not null or undefined
        if (requestp === null || requestp === undefined) {
            throw new Error('Required parameter requestp was null or undefined when calling post.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestp, "HtmlAnalysisRequest")
        };

        this.authentications.licenseCode.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AsyncResponseHtmlAnalysisResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AsyncResponseHtmlAnalysisResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SummaryApiApiKeys {
    licenseCode,
}

export class SummaryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'licenseCode': new ApiKeyAuth('header', 'licenseCode'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SummaryApiApiKeys, value: string) {
        (this.authentications as any)[SummaryApiApiKeys[key]].apiKey = value;
    }
    /**
     * Tries to get the result of a request using the task id of the request
     * @summary Tries to get the result of a request using the task id of the request
     * @param taskId 
     */
    public get (taskId: string) : Promise<{ response: http.ClientResponse; body: AsyncResponseSummaryAnalysisResponse;  }> {
        const localVarPath = this.basePath + '/api/async/summary/result/{taskId}'
            .replace('{' + 'taskId' + '}', encodeURIComponent(String(taskId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'taskId' is not null or undefined
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.licenseCode.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AsyncResponseSummaryAnalysisResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AsyncResponseSummaryAnalysisResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Gets the summary analysis of a document
     * @summary Gets the summary analysis of a document
     * @param requestp 
     */
    public post (requestp: SummaryAnalysisRequest) : Promise<{ response: http.ClientResponse; body: AsyncResponseSummaryAnalysisResponse;  }> {
        const localVarPath = this.basePath + '/api/async/summary';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestp' is not null or undefined
        if (requestp === null || requestp === undefined) {
            throw new Error('Required parameter requestp was null or undefined when calling post.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestp, "SummaryAnalysisRequest")
        };

        this.authentications.licenseCode.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AsyncResponseSummaryAnalysisResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AsyncResponseSummaryAnalysisResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TextApiApiKeys {
    licenseCode,
}

export class TextApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'licenseCode': new ApiKeyAuth('header', 'licenseCode'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TextApiApiKeys, value: string) {
        (this.authentications as any)[TextApiApiKeys[key]].apiKey = value;
    }
    /**
     * Tries to get the result of a request using the task id of the request
     * @summary Tries to get the result of a request using the task id of the request
     * @param taskId 
     */
    public get (taskId: string) : Promise<{ response: http.ClientResponse; body: AsyncResponseTextAnalysisResponse;  }> {
        const localVarPath = this.basePath + '/api/async/text/result/{taskId}'
            .replace('{' + 'taskId' + '}', encodeURIComponent(String(taskId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'taskId' is not null or undefined
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.licenseCode.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AsyncResponseTextAnalysisResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AsyncResponseTextAnalysisResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * @summary Analyses text and returns tags for it
     * @param requestp 
     */
    public post (requestp: TextAnalysisRequest) : Promise<{ response: http.ClientResponse; body: AsyncResponseTextAnalysisResponse;  }> {
        const localVarPath = this.basePath + '/api/async/text';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestp' is not null or undefined
        if (requestp === null || requestp === undefined) {
            throw new Error('Required parameter requestp was null or undefined when calling post.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestp, "TextAnalysisRequest")
        };

        this.authentications.licenseCode.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AsyncResponseTextAnalysisResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AsyncResponseTextAnalysisResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ThesaurusApiApiKeys {
    licenseCode,
}

export class ThesaurusApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'licenseCode': new ApiKeyAuth('header', 'licenseCode'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ThesaurusApiApiKeys, value: string) {
        (this.authentications as any)[ThesaurusApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns the thesaurus entries for a specific word
     * @summary Returns the thesaurus entries for a specific word
     * @param request 
     */
    public post (request: ThesaurusRequest) : Promise<{ response: http.ClientResponse; body: ThesaurusResponse;  }> {
        const localVarPath = this.basePath + '/api/thesaurus';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling post.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "ThesaurusRequest")
        };

        this.authentications.licenseCode.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ThesaurusResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ThesaurusResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WordCloudApiApiKeys {
    licenseCode,
}

export class WordCloudApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'licenseCode': new ApiKeyAuth('header', 'licenseCode'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WordCloudApiApiKeys, value: string) {
        (this.authentications as any)[WordCloudApiApiKeys[key]].apiKey = value;
    }
    /**
     * Tries to get the result of a request using the task id of the request
     * @summary Tries to get the result of a request using the task id of the request
     * @param taskId 
     */
    public get (taskId: string) : Promise<{ response: http.ClientResponse; body: AsyncResponseWordCloudResponse;  }> {
        const localVarPath = this.basePath + '/api/async/wordcloud/result/{taskId}'
            .replace('{' + 'taskId' + '}', encodeURIComponent(String(taskId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'taskId' is not null or undefined
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AsyncResponseWordCloudResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AsyncResponseWordCloudResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Analyses text and returns a word cloud (as an image)
     * @summary Analyses text and returns a word cloud (as an image)
     * @param requestp 
     */
    public post (requestp: WordCloudRequest) : Promise<{ response: http.ClientResponse; body: AsyncResponseWordCloudResponse;  }> {
        const localVarPath = this.basePath + '/api/async/wordcloud';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestp' is not null or undefined
        if (requestp === null || requestp === undefined) {
            throw new Error('Required parameter requestp was null or undefined when calling post.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestp, "WordCloudRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AsyncResponseWordCloudResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AsyncResponseWordCloudResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
